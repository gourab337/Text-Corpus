কম্পিউটার বিজ্ঞানের ভাষায় কোড হচ্ছে এমন এক ধরনের কোড, যেটি এক্সিকিউট হওয়ার সময় নিজেই নিজের কোড পরিবর্তন করতে পারে। সাধারণত কোডের লাইনসংখ্যা কমানো এবং কোড যাতে আরও দ্রুত কাজ করতে পারে, সেজন্য এটি ব্যবহার করা হয়। একাধিক শর্তযুক্ত প্রোগ্রামগুলোর বিকল্প হিসেবে কোড ব্যবহার করা হয়। কোন প্রোগ্রামে লিখা শর্তগুলো যাচাই করার বিকল্প হিসেবেও এই কোডের ব্যবহার অধিক জনপ্রিয়। এই কোড এমন পরিস্থিতিতেই ব্যবহার করা হয়, যেখানে "বাফার ফ্লো" কিংবা এই ধরনের কোন ভুলের জন্য কোড পরিবর্তিত হয়ে যাওয়ার কোন সুযোগ নেই। যেখানে একটি বড় কোড টেস্ট কিংবা ডিবাগ করার জন্য প্রতিটি ইনপুট/আউটপুটের জন্য আলাদা মেমরি, ব্যান্ডউইথ অথবা অন্য কোন কিছুর সাহায্য দরকার হয়, সেখানে এই পদ্ধতিটি সবচেয়ে বেশি ব্যবহার করা হয়। কোডের এই পরিবর্তনগুলো নিন্মোক্ত সময়গুলোতে করা যায়ঃ '''শুধুমাত্র কোডের শুরুতে''' এটি মূলত ইনপুটের উপর নির্ভর করে। বিশেষ করে প্রক্রিয়াটি সাধারণত সফ্টওয়্যার 'কনফিগারেশন' হিসেবে বর্ণনা করা হয় এবং অনুরূপভাবে হার্ডওয়্যার দ্বারা ব্যাখ্যা করতে গেলে প্রিন্টেড সার্কিট বোর্ড দরকার হয়। কোডের একটি পরোক্ষ সমতুল্য পদ্ধতি প্রোগ্রাম হচ্ছে এন্ট্রি পয়েন্টার। কিন্তু এক্ষেত্রে কয়েকটি বিকল্প নির্দেশ দরকার হয়, ফলে প্রোগ্রামের আকার বৃদ্ধি পায়। '''কোডের কাজ চলাকালীন সময়ে''' এটি কোন একটি প্রোগ্রাম চলাকালীন সময়ে কাজ করে। উভয় ক্ষেত্রেই এটি পুরাতন কোডটিকে সম্পুর্নরূপে পরিবর্তন করে নতুন একটি কোডে রুপান্তরিত করে ফেলে। কোডের এই পরিবর্তনটি সরাসরি মেশিন কোডটি বদলে ফেলে। উদাহরণস্বরূপ বলা যায়, একটি শর্তহীন কোড অথবা একটি এনওপি। এনওপি হচ্ছে অ্যাসেম্বলি ভাষার এমন একটি নির্দেশনা, যেটি প্রোগ্রাম এক্সিকিউট করার সময় কোন কাজ করেনা। আইবিএম/৩৬০ এবং ক্ষেত্রে, 'এক্সিকিউট' নির্দেশনাটি তার টার্গেট নির্দেশনাটির প্রথম রেজিস্টারের বিটের মধ্যে দ্বিতীয় বাইটটিকে যৌক্তিকভাবে পরিবর্তিত করে ফেলে। কিন্তু এই স্ব-পরিবর্তনের ফলে সংগ্রহস্থলের প্রকৃত নির্দেশনার কোন পরিবর্তন হয় না। == লো এবং হাই লেভেল প্রোগ্রামিং ভাষায় এর ব্যবহারঃ == প্রোগ্রামিং ভাষার উপর ভিত্তি করে কোডের স্ব-পরিবর্তন বিভিন্নভাবে হতে পারে। এটি পয়েন্টারে পরিবর্তনশীল কম্পাইলার বা ইন্টারপ্রেটার ইঞ্জিনের সাহায্যেও হতে পারেঃ '''পূর্ববর্তী নির্দেশনাবলী পরিবির্তিত করে''' অথবা নির্দেশনাবলী একটি অংশ যেমন অপকোড, রেজিস্টার, ফ্ল্যাগ বা অ্যাড্রেস) অথবা '''সরাসরি সম্পূর্ন নির্দেশাবলী তৈরি করে''' অথবা মেমরিতে থাকা ক্রমানুযায়ী নির্দেশাবলী '''সোর্স কোড তৈরি অথবা পরিমার্জন করে '''একটি 'মিনি কম্পাইলার' অথবা পরিবর্তনশীল ইন্টারপ্রেটার ব্যবহার করে ''' একটি সম্পূর্ণ পরিবর্তনশীল প্রোগ্রাম তৈরি করা''' এবং তারপর সেটি এক্সিকিউট করা === অ্যাসেম্বলি ভাষা === অ্যাসেম্বলি ভাষা ব্যবহার করে স্ব-পরিবর্তনশীল কোড বাস্তবায়ন করা মোটামুটি সহজ। এক্ষেত্রে নির্দেশনাগুলো মেমরিতে নতুন করে তৈরি করা যায় এবং এগুলো পরিবর্তনশীল। অথবা পূর্বের অসুরক্ষিত কোড মুছে ফেলেও আগের মেমরিতেই নতুন করে কোড করা যায়। উভয়ক্ষেত্রেই এমনভাবে কোড লিখতে হয়, যেন একটি সাধারণ কম্পাইলার সহজেই কোডটিকে অবজেক্ট কোড হিসাবে তৈরি করতে পারে। এক্ষেত্রে আধুনিক প্রসেসর ব্যবহার করা হলে, সেখানে সিপিইউ ক্যাশে কিছু অনিচ্ছাকৃত পার্শ্ব প্রতিক্রিয়া হতে পারে। এই পদ্ধতিটি অ্যাসেম্বলি ভাষায় লিখা কোডের প্রথম শর্তটি পরীক্ষা করার জন্য বেশি ব্যবহার করা হয়। এর একটি উৎকৃষ্ট উদাহরণ হচ্ছে আইবিএম/৩৬০ এর অ্যাসেম্বলি ভাষা। অ্যাসেম্বলি ভাষায় স্ব-পরিবর্তনশীল কোড ব্যবহার করলে নির্দেশনাবলী পরিমান (N 1)-1 সংখ্যক কমে। এখানে হচ্ছে ফাইলে রেকর্ডের সংখ্যা। (পূর্বের অসুরক্ষিত কোড মুছে ফেলে নতুন কোড লিখার কারণে -1 ব্যবহার করা হয়েছে)। SUBRTN NOP OPENED FIRST TIME HERE? The NOP is x'4700' OI SUBRTN+1,X'F0' YES, CHANGE NOP TO UNCONDITIONAL BRANCH (47F0...) OPEN INPUT AND OPEN THE INPUT FILE SINCE IT'S THE FIRST TIME THRU OPENED GET INPUT NORMAL PROCESSING RESUMES HERE ... বিকল্প কোডটিকে প্রতিবারই একটি 'ফ্ল্যাগ' পরীক্ষার মাধ্যমে যেতে হয়। এই নিঃশর্ত শাখাটি পূর্বের কোডের চেয়ে সামান্য দ্রুত এবং সেইসাথে সামগ্রিকভাবে কোডের দৈর্ঘ্যও হ্রাস করে। পরবর্তীতে অপারেটিং সিস্টেমগুলোতে প্রোগ্রামগুলো সুরক্ষিত মেমরিতে রাখার ফলে এই পদ্ধতি আর ব্যবহার করা হত না। এর বদলে পয়েন্টারটিকে সাবরুটিনে পরিবর্তন করে দেয়া হত। এক্ষেত্রে পয়েন্টারটি পরিবর্তনশীল মেমরিতে রাখা যেতে পারে। এখানে কোডের শাখার বদলে পয়েন্টারটি লোড করতে হয় এবং সাবরুটিনে যুক্ত করতে হয়। এতে করে প্রোগ্রামের কোডে নির্দেশনার পরিমান বাড়ে। কিন্তু যেহেতু এখানে নিঃশর্ত শাখাগুলোর কোন দরকার হয়না, সেহেতু তুলনামুলকভাবে সম্পূর্ন প্রোগ্রামের লাইন সংখ্যা কমে। === হাই লেভেল প্রোগ্রামিং ভাষা === কিছু প্রোগ্রামিং ভাষায় স্পষ্টভাবে কোড সমর্থন করে। উদাহরণস্বরূপ, ব্যবসায়িক কাজে ব্যবহৃত এক বিশেষ ধরনের কম্পিউটার ভাষা, কোবোলে কোড এক্সিকিউট হওয়ার সময় কোড কাজ করতে পারে। এক-ব্যাচ প্রোগ্রামিং ভাষায় কোড ব্যবহার করতে হয়। এছাড়াও 'ক্লিপার' এবং 'এসপিআইটিবিওএল' প্রোগ্রামিং ভাষাগুলোও সরাসরি কোডের সুবিধা প্রদান করে। বি৬৭০০ সিস্টেমে ব্যবহৃত অ্যালগল কম্পাইলার কোড এক্সিকিউট হওয়ার সময় টেক্সট স্ট্রিং চালনা করতে পারে এবং পরে আবার সেটিকে প্রয়োজন হলে পুনরায় ডেকে ব্যবহারও করতে পারে। কিছু কিছু প্রোগ্রামিং ভাষায় মেশিন কোডই হচ্ছে সোর্স কোড এবং এই কোড সবসময়ই পরিবর্তন করা যায়। স্নোবল প্রোগ্রামিং ভাষায় সোর্স কোড একটি টেক্সট অ্যারে এর উপাদান হিসিবে এক্সিকিউট হয়। অন্যান্য প্রোগ্রামিং ভাষা যেমন পার্ল এবং পাইথনে প্রোগ্রামগুলো রান-টাইমে 'ইভাল' ফাংশন ব্যবহার করে নতুন কোড তৈরি করতে পারে, কিন্তু পূর্বের কোডে কোনরূপ পরিবর্তন করতে পারে না। এই পরিবর্তন বিষয়ক বিভ্রমটি (এমনকি মেশিন কোডও মূলত বদলানো হয়না) ফাংশন পয়েন্টারে পরিবর্তন করার কারণে ঘটে থাকে। নিচের জাভাস্ক্রিপ্টের উদাহরণটি লক্ষ্য করা যাকঃ var function (x) {return 1}; // assign new definition to f: new Function('x', 'return 2'); 'লিস্প ম্যাক্রোস' এর সাহায্যে একটি প্রোগ্রামে থাকা স্ট্রিং এর কোনরূপ শব্দবিশ্লেষণ ছাড়াই রানটাইমে কোড পরিবর্তন করার সুযোগ পায়। প্যুশ প্রোগ্রামিং ভাষা এমন একটি প্রোগ্রামিং ভাষা, যেটি সহজে কোড ব্যবহার করার জন্য তৈরি করা হয়েছে। এটি কোন উচ্চ স্তরের প্রোগ্রামিং ভাষা নয়, কিন্তু অ্যাসেম্বলি ভাষার মত নিন্ম স্তরেরও নয়। ==== চক্রবৃদ্ধি পরিবর্তন ==== একাধিক উইন্ডোজ সিস্টেম আসার আগে, কমান্ড-লাইন সিস্টেমে একটি মেন্যু সিস্টেম থাকতো, যার সাহায্যে রানিং কমান্ডের কোড পরিবর্তন করার সুযোগ ছিল। মনে করুন, একটি ডিওএস স্ক্রিপ্ট ফাইল Menu.bat তে নিচের কোডগুলো থাকতে পারেঃ :StartAfresh i, wi এর সাথে যুক্ত হবে এবং প্রতিটি ইনডেক্সে ওয়েট থাকলে সেখানে হিসাবটি দুটি নিয়মে হতে পারে। একটি নিয়ম হচ্ছে ওয়েট ব্যবহার করে এবং অপরটি হচ্ছে ওয়েট ব্যবহার ছাড়া। এখন আরও একটি নিয়ম বিবেচনা করা যাক, ইনডেক্সের প্রতিটি মানই একটি সম্ভাব্য বুলিয়ান মানের সাথে যুক্ত আছে যাতে করে সেটা নিশ্চিত করা যায় যে, মানটি নিয়ে কাজ করা হবে নাকি হবে না। এই কোডটি চারটি ব্যাচে নিয়ন্ত্রণ করা যায়, এর একটি হচ্ছে উত্পাদক দ্বারা কোডটির ফলাফল বের করা এবং এই পদ্ধতিতে কোডের আকার বৃদ্ধি পাবে। অথবা, আরও একটি উপায় হল যে অ্যারেগুলো এড়িয়ে যাওয়া হয়েছিল সেগুলো এবং তাদের ওয়েট একত্রে যুক্ত করে একটি সাময়িক অ্যারেতে রাখা। এখানেও কোড কাজ করার সময় কোডের আকার বৃদ্ধি পাবে। যাইহোক, এভাবে কোড সামান্য পরিবর্তন করে পরিসংখ্যানের হিসাব করা হলে সেখানে অপ্রয়োজনীয় মানগুলো আর থাকবে না এবং কোডও সম্পুর্ন সঠিক হবে। এখানে কোন মান দ্বিতীয়বার যাচাই করা হবে না এবং ডেটা অ্যারে কেবলমাত্র একবারই চেক করা হবে। === ছদ্মবেশ হিসাবে ব্যবহার === ১৯৮০ সালে অ্যাপল এবং আইবিএম পিসিতে ডিস্কের উপর ভিত্তি করে বানানো প্রোগ্রামগুলোতে কোড যাতে কেউ নকল করতে না পারে, সেজন্য কোড ব্যবহার করা হত। উদাহরণস্বরূপ, একটি আইবিএম পিসিতে থাকা ফ্লপি ডিস্কে 'int 0x13' নামক কোড থাকতো যেটি প্রোগ্রামের তালিকায় দেখাতো না। কিন্তু এই কোডটি মেমরিতে থাকতো এবং স্বনিয়ন্ত্রিত ভাবে এই প্রোগ্রামটি কাজ করা শুরু করত। কিছু কিছু প্রোগ্রাম, যেখানে প্রোগ্রামার কোডের উপস্থিতি লুকিয়ে রাখতে চাইতো, সেখানে কোড ব্যবহার করা হত। যেমন কম্পিউটার ভাইরাস এবং কিছু হ্যাকিং এর জন্য ব্যবহৃত শেলকোড ইত্যাদি। ভাইরাস এবং এই শেলকোড যেগুলো কোড ব্যবহার করে সেগুলো সাধারণত পলিমরফিক কোড ব্যবহার করে লুকায়িত কোডটি আসল কোডের সাথে যুক্ত করা হয়। একটি কোড কাজ করার সময় কোডে পরিবর্তন করে সেই কোড কম্পিউটার হ্যাকিং করার জন্য ব্যবহার করা যায়। বাফার ওভারফ্লো হচ্ছে এর একটি উৎকৃষ্ট উদাহরণ। === স্ব-উল্লেখ মেশিন লার্নিং সিস্টেম === গতানুগতিক মেশিন লার্নিং সিস্টেমে সাধারণত একটি নির্দিষ্ট এবং পূর্বে প্রোগ্রাম করা অ্যালগরিদম ব্যবহার করা হয়। অতঃপর ১৯৮০ সালে জর্জেন স্কিম্বার বেশ কয়েকটি কোডের নিয়ম আবিষ্কার করেন যেগুলো নিজে নিজেই তাদের নিজস্ব অ্যালগরিদমে পরিবর্তন ঘটাতে পারতো। এমনকি এটি কোডের জন্য বিপদজনক যেকোনো কোডের ব্যাপারে সতর্ক ছিল এবং যেকোনো প্রকার বিপদজনক কোড সহজেই মুছে ফেলতে পারতো। কোডের এই স্ব-পরিমার্জন এই বিষয়টি নিশ্চিত করে যে, ব্যবহারকারী যদি সঠিকভাবে ফিটনেস, এরর অথবা রিওয়ার্ড ফাংশন ব্যবহার করে কেবলমাত্র তাহলেই কোডে স্ব-পরিমার্জন ঘটবে। === অপারেটিং সিস্টেম === যেহেতু কোডে স্ব-পরিমার্জনের ফলে কম্পিউটারের নিরাপত্তা বিঘ্নিত হওয়ার সম্ভাবনা থাকে, সুতরাং প্রায় সকল অপারেটিং সিস্টেমেই কোড পাওয়ামাত্রই সেটি মুছে দেয়। কোডটির নিজে থেকে স্ব-পরিমার্জন বৈশিষ্ট্য থাকার জন্য নয়, বরং এই কোডটি কম্পিউটারের ক্ষতি করার সম্ভাবনা থাকে বলেই অপারেটিং সিস্টেম কোডটি মুছে দেয়। এর ফলে কম্পিউটারে অনেক সমস্যা হতে পারে। সুতরাং এই সমস্যাটি সমাধান করার জন্য অপারেটিং সিস্টেমগুলো নতুন একটি ফিচার তৈরি করে। এর নাম দেয়া হয় W^X ("রাইট এক্সওআর এক্সিকিউট" করার জন্য)। এটি মূলত সকল প্রোগ্রামগুলোকে কাজ করতে বাধা দেয়, যেগুলো কোড ব্যবহার করার সময় কোডে কোনরূপ পরিবর্তন করে। কোন প্রোগ্রামে যদি কোড পরিবর্তনের ব্যাপারটি নিষেধ না থাকে, তাহলেই কিছু কিছু অপারেটিং সিস্টেম সরাসরি প্রোগ্রামটি এক্সিকিউট করতে বাধা দেয়। অন্যান্য অপারেটিং সিস্টেমগুলোতে 'ব্যাক ডোর' নামক অপশন থাকে, যার মাধ্যমে বিভিন্ন প্রোগ্রামে দেওয়া পারমিশন সম্পর্কে সিস্টেম অবহিত থাকে। এই W^X ফিচারটি এড়িয়ে যাওয়ার সবচেয়ে সহজ উপায় হল সকল পারমিশন দিয়ে একটি ফাইল তৈরি করা এবং তারপর সেটি মেমরিতে দুইবার রাখা। লিনাক্সে এটি ছাড়াও কেউ ইচ্ছা করলে একটি অনথিভুক্ত সিসভি মেমোরি ফ্ল্যাগ তৈরি করেও এই ফিচারটি সহজে এড়িয়ে যাওয়া যায়। এই পদ্ধতিটি ব্যবহার করলে নতুন কোন ফাইল তৈরী করতে হয়না। এছাড়াও কম্পিউটার পলিমরফিজম ব্যবহার করে প্রোগ্রামের সর্বত্র ব্যবহার করা নিজস্ব ডেটা পরিবর্তন করেও প্রোগ্রামের কর্মপদ্ধতি নিজে নিজেই পরিবর্তন করতে পারে। === ক্যাশ এবং কোডের মিথষ্ক্রিয়া === আর্কিটেকচারে ডেটা এবং নির্দেশ মিলিত হয়ে ক্যাশে জমা হয় এবং এই মিথষ্ক্রিয়া করার জন্য ক্যাশ সিঙ্ক্রোনাইজেশন অবশ্যই পরিবর্তিত কোড দ্বারা সঞ্চালিত করতে হবে। আধুনিক প্রসেসরে কিছু কিছু ক্ষেত্রে স্ব-পরিবর্তনশীল কোড খুব ধীরে কাজ করে। এর কারণ হল, আধুনিক প্রসেসর সাধারণত তার ক্যাশ মেমরিতে এক্সিকিউট হওয়া কোডগুলো রাখার চেষ্টা করে। প্রতিবার প্রোগ্রাম যখন এর একটি অংশ একটু পরিবর্তন করে, তখন পুনর্লিখিত অংশ আবার ক্যাশের মধ্যে লোড করার দরকার হয়। যদি পরিবর্তীত কোড এবং পূর্বের কোড একই ক্যাশ মেমরি ব্যবহার করে, তাহলে ফলাফল আসতে সামান্য বিলম্ব হয়। কারণ এখানে পরিবর্তীত কোডটির মেমরি অ্যাড্রেস পূর্বের কোডের অ্যাড্রেসের কয়েক বাইটের মধ্যেই অবস্থান করে। আধুনিক প্রসেসরের ক্যাশ বিষয়ক এই সমস্যাটি তখনই সমাধান হবে, যখন স্ব-পরিবর্তনশীল কোডগুলো তাদের কোড খুব কম সময় পরিবর্তন করে। যেমন, ইনার লুপের ভিতরে যেভাবে লুপ পরিবর্তন হয় সেভাবে। অধিকাংশ আধুনিক প্রসেসরই কোন একটি প্রোগ্রাম এক্সিকিউট করার আগেই প্রোগ্রামটির সম্পূর্ন মেশিন কোড মেমরিতে লোড করে নেয়। এর মানে যদি একটি কোড পূর্বের কোডের চেয়ে খুব কম পরিমাণে পরিবর্তন করা হয়, তাহলে প্রসেসর সেটি লক্ষ্য করবে না। কম্পিউটারের প্রসেসরগুলো অবশ্যই সঠিকভাবে স্ব-পরিবর্তনশীল কোড নিয়ন্ত্রণ করতে হবে, কিন্তু তারা এখনো সেটি করতে পারছে না। === ম্যাসালিন এর সংশ্লেষণ কার্নেল === ডক্টর অ্যালেক্সিয়া ম্যাসালিনের পিএইচডি থিসিসে তিনি সংশ্লেষণ কার্নেলের ব্যাপারে গবেষণা করেন। তিনি একটি ক্ষুদ্র ইউনিক্স কার্নেল ব্যবহার করে একটি স্ব-পরিবর্তনশীল কোড তৈরি করেন। এটি স্ট্রাকচার্ড প্রোগ্রামিং ভাষা এবং অবজেক্ট ওরিয়েন্টেড উভয় ভাষাতেই করা যায়। তার এই কোডটি সহজেই বিভিন্ন অবজেক্ট তৈরি করতে পারতো, যেমন ফাইল হ্যান্ডেলার। এই সংশ্লেষণ কার্নেলটি অত্যন্ত দ্রুতগতির ছিল, কিন্তু এটি সম্পূর্ণরূপে অ্যাসেম্বলি ভাষায় লেখা হয়েছিল। ফলে এটি আর অন্য কোন ভাষায় অপটিমাইজ করতে না পারায়, এটি তেমন জনপ্রিয় হয়নি। যাইহোক, এটি একটি বিষয় প্রমাণ করেছিল যে, স্ব-পরিবর্তনশীল কোড যেকোনো মধ্য স্তর কিংবা উচ্চ স্তরের প্রোগ্রামিং ভাষায় লিখা সম্ভব। এতে করে আরও সহজেই খুব দ্রুতগতির বিভিন্ন অপারেটিং সিস্টেম অথবা প্রোগ্রাম তৈরি করা যাবে। পল হাবার্লি এবং ব্রুস কার্শ স্ব-পরিবর্তনশীল কোডের প্রান্তিকীকরণের বিরোধিতা করেন। তাদের মতে এতে করে বিভিন্ন অপারেটিং সিস্টেম অথবা প্রোগ্রাম তৈরিতে খরচের পরিমান বৃদ্ধি পাবে। == সুবিধাসমূহ == স্ব-পরিবর্তনশীল কোড ব্যবহার করে সহজেই বিভিন্ন প্রোগ্রাম এক্সিকিউট করা যায়, এতে করে এবং শর্তযুক্ত কোডের পরিমান কমে যায়। স্ব-পরিবর্তনশীল কোড আলগোরিদিমিক দক্ষতা আরও উন্নত করতে পারে। == অসুবিধাসমূহ == স্ব-পরিবর্তনশীল কোড পড়া এবং পরিচালনা করা অত্যন্ত কঠিন। কারণ যে প্রোগ্রামটি এক্সিকিউট হবে, সেটির সোর্স কোডে সাধারণত স্ব-পরিবর্তনশীল কোডগুলোর ব্যাপারে কোন নির্দেশ দেয়া থাকে না। স্ব-পরিবর্তনশীল কোডগুলোর যেগুলো ফাংশন পয়েন্টারের প্রতিকল্পন দিয়ে গঠিত হয়, সেগুলো অত বেশি কঠিন হয় না। এগুলো সোর্স কোডে তাদের ব্যবহৃত ফাংশনগুলোর নাম উল্লেখ করে দেয়, যাতে করে পরবর্তীতে কোড দেখার সময় সহজেই কোডটি বুঝা যায়। স্ব-পরিবর্তনশীল কোড এমনভাবেও লিখা যায়, যেখানে এটি কোডের বিভিন্ন ফ্ল্যাগ এবং শাখা পরখ করে দেখে যে কিভাবে কোডটি এক্সিকিউট করলে সহজে ফলাফল আসবে। এতে করে সময় লাগে একটু বেশি। কিন্তু তুলনামুলকভাবে স্ব-পরিবর্তনশীল কোড দ্রুত কাজ করে। আধুনিক প্রসেসরে যেখানে অনেকগুলো নির্দেশ দেয়া থাকে এবং তার উপর স্ব-পরিবর্তনশীল কোড থাকে, সেখানে যদি কোড নিজে নিজেই ঘন ঘন কোড পরিবর্তন করে তাহলে সময় বেশি লাগে। তাছাড়া ক্যাশে কোড জমা রাখা এবং পুনরায় ক্যাশ থেকে কোড লোড করতেও অনেক সময় লাগে। এই ধরনের প্রসেসরে কোড সঠিকভাবে এক্সিকিউট হয়েছে কিনা সেটি বুঝার একমাত্র উপায় হল নির্দেশনা সেট সম্পূর্নরূপে পরিষ্কার করে ফেলা এবং পুনরায় নতুন করে নির্দেশনা দেয়া। স্ব-পরিবর্তনশীল কোড সবসময় ব্যবহার করা যায় না। যেসকল অবস্থায় স্ব-পরিবর্তনশীল কোড ব্যবহার করা যায় না, সেগুলো নিচে দেয়া হল: যেসকল অ্যাপ্লিকেশন সফটওয়ার এমন অপারেটিং সিস্টেমে চলে যেখানে শক্তিশালী W^X নিরাপত্তা ব্যবহার করা হয়, সেখানে কিছুতেই স্ব-পরিবর্তনশীল কোড কাজ করেনা। এই সকল অপারেটিং সিস্টেমগুলো কেবল মেমরিতে কোড পরিবর্তন করতে পারে। কোড কাজ করা শুরু করলে আর কোডের নির্দেশনাবলী পরিবর্তন করতে পারেনা। হার্ভার্ডে তৈরি হওয়া অনেক স্ব-পরিবর্তনশীল কোডের নির্দেশনাবলী কাজ করেনা। সেখানে কেবল রম অথবা যেসকল মেমোরি স্বয়ংক্রিয় নয়, সেখানে কোড রাখতে পারে। যদি কোন প্রোগ্রাম স্ব-পরিবর্তনশীল কোড দিয়ে একাধিক কাজ একসাথে করতে চায়, তাহলে সেখানে কোন কাজ হয়না। উপরন্তু সেখানে কমপিউটেশন ভুল দেখায় অথবা সম্পূর্ন অ্যাপ্লিকেশনটিই অকৃতকার্য হয়ে পড়ে। == আরো দেখুন == Algorithmic efficiency eval statement IBM 1130 (Example) Just-in-time compilation: This technique can often give users many of the benefits of self-modifying code (except memory size) without the disadvantages. Dynamic dead code elimination PCASTL Quine (computing) Reflection (computer science) Monkey patch: modification to runtime code that does not affect program's original source code Extensible programming: programming paradigm in which programming language can modify its own syntax কম্পিউটার ভাইরাস == তথ্যসূত্র == == বহিঃসংযোগ == Using self-modifying code under Linux Self-modifying code Web Archive version) "Synthesis: An Efficient Implementation of Fundamental Operating System Services": Alexia Massalin's Ph.D. thesis on the Synthesis kernel Futurist Programming Certified Self-Modifying Code Jürgen Schmidhuber's publications on self-modifying code for machine learning systems