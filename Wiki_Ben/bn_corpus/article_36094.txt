সি++ প্রোগ্রামিং ল্যাঙ্গুয়েজ এ, হল সি++ স্ট্যান্ডার্ড লাইব্রেরির গুরুত্বপূর্ণ অংশ। এই লাইব্রেরিটি লিস্ট এবং সেট এর মত আরও গুরুত্বপূর্ণ কিছু ডেটা স্ট্রাকচার প্রদান করে, সাধারণভাবে যাদের কন্টেইনার বলা হয়ে থাকে। এই কন্টেইনারগুলোর একটি সাধারণ ফিচার হচ্ছে রান টাইমে আকার পরিবর্তন করা, যা অর্জন করা হয় ডাইনামিক মেমরি অ্যালোকেশন এর মাধ্যমে। একটি কন্টেইনার এর মেমোরিতে স্থান নির্ধারণ এবং অপসারণ, অ্যালোকেটর পরিচালনা করে থাকে। সি++ স্ট্যান্ডার্ড লাইব্রেরি সাধারণ ব্যবহার্য অ্যালোকেটর প্রদান করে থাকে, আবার একজন প্রোগ্রামারও তার নিজস্ব অ্যালকেটর সরবরাহ করতে পারেন। সি++ স্ট্যান্ডার্ড স্ট্যান্ডার্ড লাইব্রেরির অংশ হিসেবে অ্যালেকজান্ডার স্টেপানভ অ্যালোকেটর উদ্ভাবন করেন। এর মূল উদ্দেশ্য ছিল লাইব্রেরিটিকে আরও সহজলভ্য এবং মুল মেমোরি মডেল থেকে স্বাধীন করা, যাতে প্রোগ্রামাররা লাইব্রেরির সাথে নিজস্ব পয়েন্টার এবং রেফারেন্স টাইপ ব্যবহার করতে পারেন। এস,টি,এল কে সি++ স্ট্যান্ডার্ডে গ্রহণ করার প্রক্রিয়ায়, সি++ মান নির্ধারণ পরিষদ উপলব্ধি করে যে, মেমোরি মডেলের পূর্ণ বিমূর্তণ অপ্রীতিকর কর্মসম্পাদন সাধন করতে পারে। এর বিহিত করার জন্য, অ্যালোকেটরের আবশ্যিকতা নিয়ন্ত্রণ করা হয়েছে। এর ফলে, স্টেপানভের প্রকৃত উদ্ভাবনের চেয়ে নিজস্ব অ্যালোকেটরের ব্যবহার অত্যন্ত সীমিত। তা সত্ত্বেও, কিছু ক্ষেত্রে নিজস্ব অ্যালোকেটরের ব্যবহারই কাম্য। নিজস্ব অ্যালোকেটর লেখার কিছু সাধারণ কারণ হল মেমোরি পুল ব্যবহার করে মেমোরিতে স্থান নির্ধারণের গতি উন্নতি করা, এবং বিভিন্ন ধরনের মেমোরির প্রবেশাধিকার সংরক্ষণ করা যেমন শেয়ারকৃত মেমোরি অথবা গারবেজ-সংগৃহীত মেমোরি। প্রকৃতপক্ষে, যেসকল প্রোগ্রাম স্বল্প মেমোরি বারংবার নির্ধারণ করে থাকে, সেগুলো বিশেষায়িত অ্যালোকেটর এর উপকারিতা লাভ করতে পারে রান টাইম এবং মেমোরি ফুটপ্রিন্ট এর ক্ষেত্রে। ==পটভূমি== অ্যালেকজান্ডার স্টেপানভ এবং মেং লী ১৯৯৪ সালের মার্চ মাসে সি++ মান নির্ধারক পরিষদের কাছে স্ট্যান্ডার্ড টেম্পলেট লাইব্রেরী (এস,টি,এল) উপস্থাপন করেন। বেশ কিছু ইস্যু থাকা সত্ত্বেও লাইব্রেরিটি প্রাথমিক অনুমোদন পায়। প্রকৃতপক্ষে, স্টেপানভকে লাইব্রেরী কন্টেইনারগুলোকে মূল মেমোরি মডেল থেকে স্বাধীন করার জন্য অনূরোধ করা হয়েছিল, যা থেকেই মূলতঃ অ্যালোকেটর উদ্ভাবিত হয়। ফলস্বরূপ, সকল এস,টি,এল কন্টেইনার ইন্টারফেসগুলোকে আবার নতুন ভাবে লিখতে হয়েছিল যাতে তারা অ্যালোকেটর গ্রহণ করতে পারে। এস,টি,এল কে সি++ স্ট্যান্ডার্ড লাইব্রেরিতে অন্তর্ভুক্তির কাজে স্টেপানভ মান নির্ধারক পরিষদের কয়েকজন সদস্যদের সাথে ঘনিষ্ঠভাবে কাজ করেছেন, অ্যান্ড্রু কেইনিগ এবং বিয়ারনে স্ট্রোভস্ট্রুপ তাদের মধ্যে অন্যতম, যারা লক্ষ্য করেন যে রূপান্তরিত ব্যবহার করা যেতে পারে স্থায়ী স্টোরেজ এস,টি,এল কন্টেইনার সম্পাদনের ক্ষেত্রে, যেটা সেসময় স্টেপানভ "গুরুত্বপূর্ণ এবং কৌতূহল উদ্দীপক দূরদৃষ্টি" হিসেবে বিবেচনা করেন। From the point of view of portability, all the things which relate to the notion of address, pointer, and so on, are encapsulated within tiny, well-understood mechanism. —অ্যালেকজান্ডার স্টেপানভ, স্টান্ডার্ড টেম্পলেট লাইব্রেরির নকশাকার। মূল অ্যালোকেটরের প্রস্তাবে প্রোগ্রামিং ভাষার কিছু বৈশিষ্ট্য অন্তর্ভুক্ত ছিল যা এখনও পরিষদ দ্বারা গৃহীত হয় নাই, যেমন টেম্পলেট আর্গুমেন্ট ব্যবহার করা যারা নিজেরাই টেম্পলেট। যেহেতু এইসব বৈশিষ্ট্য বিদ্যমান কোনো কম্পাইলার কম্পাইল করতে পারে না, তখন স্টেপানভের মতে, "অসম্পাদিত বৈশিষ্ট্যগুলো আমরা সঠিক ভাবে ব্যবহার করি তা যাচাই করতে বিয়ারনে স্ট্রোভস্ট্রুপ এবং অ্যান্ড্রু কেইনিগ প্রচুর সময়ের প্রয়োজন ছিল।" লাইব্রেরিটি ইতিপূর্বে পয়েন্টার এবং রেফারেন্স টাইপ সরাসরি ব্যবহার করছিল, এটা এখন শুধুমাত্র অ্যালোকেটর দ্বারা সংজ্ঞায়িত টাইপসমূহকেই নির্দেশ করতে পারে। স্টেপানভ পরে অ্যালোকেটরের বর্ণনা দেন এরকমঃ "এস,টি,এল এর একটি চমৎকার বৈশিষ্ট্য হচ্ছে যে স্থানে মেশিন-সংশ্লিষ্ট টাইপ উল্লেখ করা হয় তা মোটামুটি ১৬ লাইন কোডের মধ্যে নিরাপদে আছে।" যদিও স্টেপানভ মেমোরি মডেলের পরিপূর্ণ নিরাপত্তা মূলত দ্বারা সঙ্কল্পিত করেন, মান নির্ধারক কমিটি উপলব্ধি করে যে এই উপায় অপ্রীতিকর কার্যকারিতা অবক্ষয়ের দিকে নিয়ে যেতে পারে। এর প্রতিকার করার জন্য, অতিরিক্ত বাক্য আবশ্যিকতায় যুক্ত করা হয়। নির্দিষ্টভাবে, কনটেইনার এর বাস্তবায়ন এটা মনে করতে পারে যে, পয়েন্টার এবং ইন্টেজার টাইপের জন্য অ্যালোকেটরের সংজ্ঞা ডিফল্ট অ্যালোকেটরের সমতুল্য।, In particular, container implementations may assume that the allocator's type definitions for pointers and related integral types are equivalent to those provided by the default allocator, and that all instances of given allocator type always compare equal, effectively contradicting the original design goals for allocators and limiting the usefulness of allocators that carry state. Stepanov later commented that, while allocators "are not such bad idea in theory (...) unfortunately they cannot work in practice". He observed that to make allocators really useful, change to the core language with regards to references was necessary. The 2011 revision of the C++ Standard removed the weasel words requiring that allocators of given type always compare equal and use normal pointers. These changes make stateful allocators much more useful and allow allocators to manage out-of-process shared memory. The current purpose of allocators is to give the programmer control over memory allocation within containers, rather than to adapt the address model of the underlying hardware. In fact, the revised standard eliminated the ability of allocators to represent extensions to the C++ address model, formally (and deliberately) eliminating their original purpose. ==আবশ্যকতা== Any class that fulfills the ''allocator requirements'' can be used as an allocator. In particular, class capable of allocating memory for an object of type must provide the types A::pointer, A::reference, and A::value_type for generically declaring objects and references (or pointers) to objects of type T. It should also provide type A::size_type, an unsigned type which can represent the largest size for an object in the allocation model defined by A, and similarly, signed integral that can represent the difference between any two pointers in the allocation model. Although conforming standard library implementation is allowed to assume that the allocator's A::pointer and are simply typedefs for T* and const*, library implementors are encouraged to support more general allocators. An allocator, A, for objects of type must have member function with the signature A::pointer n, hint 0). This function returns pointer to the first element of newly allocated array large enough to contain objects of type T; only the memory is allocated, and the objects are not constructed. Moreover, an optional pointer argument (that points to an object already allocated by A) can be used as hint to the implementation about where the new memory should be allocated in order to improve locality. However, the implementation is free to ignore the argument. The corresponding void p, A::size_type n) member function accepts any pointer that was returned from previous invocation of the A::allocate member function and the number of elements to deallocate (but not destruct). The A::max_size() member function returns the largest number of objects of type that could be expected to be successfully allocated by an invocation of A::allocate; the value returned is typically sizeof(T). Also, the A::address member function returns an A::pointer denoting the address of an object, given an A::reference. Object construction and destruction is performed separately from allocation and deallocation. The allocator is required to have two member functions, A::construct and A::destroy, which handles object construction and destruction, respectively. The semantics of the functions should be equivalent to the following: template void p, t) new ((void*) p) T(t); template void p){ ((T*)p)->~T(); The above code uses the placement new syntax, and calls the destructor directly. Allocators should be An allocator for objects of type can be constructed from an allocator for objects of type U. If an allocator, A, allocates region of memory, R, then can only be deallocated by an allocator that compares equal to A. Allocators are required to supply template class member template struct A::rebind typedef other; };, which enables the possibility of obtaining related allocator, parameterized in terms of different type. For example, given an allocator type IntAllocator for objects of type int, related allocator type for objects of type long could be obtained using ==নিজস্ব One of the main reasons for writing custom allocator is performance. Utilizing specialized custom allocator may substantially improve the performance or memory usage, or both, of the program. The default allocator uses operator new to allocate memory. This is often implemented as thin layer around the heap allocation functions, which are usually optimized for infrequent allocation of large memory blocks. This approach may work well with containers that mostly allocate large chunks of memory, like vector and deque. However, for containers that require frequent allocations of small objects, such as map and list, using the default allocator is generally slow. Other common problems with malloc-based allocator include poor locality of reference, and excessive memory fragmentation. popular approach to improve performance is to create memory pool-based allocator. Instead of allocating memory every time an item is inserted or removed from container, large block of memory (the memory pool) is allocated beforehand, possibly at the startup of the program. The custom allocator will serve individual allocation requests by simply returning pointer to memory from the pool. Actual deallocation of memory can be deferred until the lifetime of the memory pool ends. An example of memory pool-based allocators can be found in the Boost C++ Libraries. Another viable use of custom allocators is for debugging memory-related errors. This could be achieved by writing an allocator that allocates extra memory in which it places debugging information. Such an allocator could be used to ensure that memory is allocated and deallocated by the same type of allocator, and also provide limited protection against overruns. In short, this paragraph (...) is the Standard's "I have dream" speech for allocators. Until that dream becomes common reality, programmers concerned about portability will limit themselves to custom allocators with no state —Scott Meyers, ''Effective STL'' The subject of custom allocators has been treated by many C++ experts and authors, including Scott Meyers in ''Effective STL'' and Andrei Alexandrescu in ''Modern C++ Design''. Meyers emphasises that C++98 requires all instances of an allocator to be equivalent, and notes that this in effect forces portable allocators to not have state. Although the C++98 Standard did encourage library implementors to support stateful allocators, Meyers calls the relevant paragraph "a lovely sentiment" that "offers you next to nothing", characterizing the restriction as "draconian". In The C++ Programming Language, Bjarne Stroustrup, on the other hand, argues that the "apparently draconian restriction against per-object information in allocators is not particularly serious", pointing out that most allocators do not need state, and have better performance without it. He mentions three use cases for custom allocators, namely, memory pool allocators, shared memory allocators, and garbage collected memory allocators. He presents an allocator implementation that uses an internal memory pool for fast allocation and deallocation of small chunks of memory, but notes that such an optimization may already be performed by the allocator provided by the implementation. ===ব্যবহার=== When instantiating one of the standard containers, the allocator is specified through template argument, which defaults to std::allocator: namespace std template class vector; // ... Like all C++ class templates, instantiations of standard library containers with different allocator arguments are distinct types. function expecting an std::vector argument will therefore only accept vector instantiated with the default allocator. ===সি++১১ অ্যালোকেটরের উন্নতি=== The C++11 standard has enhanced the allocator interface to allow "scoped" allocators, so that containers with "nested" memory allocations, such as vector of strings or map of lists of sets of user-defined types, can ensure that all memory is sourced from the container's allocator. ==উদাহরণ== Class Template Reference /** processor vendor_id AuthenticAMD cpu family 16 model model name AMD Athlon(tm) II X2 270 Processor stepping microcode 0x10000c8 cpu MHz 2000.000 cache size 1024 KB ... processor vendor_id AuthenticAMD cpu family 16 model model name AMD Athlon(tm) II X2 270 Processor stepping microcode 0x10000c8 cpu MHz 800.000 cache size 1024 KB ... Linux debian 3.14-2-686-pae #1 SMP Debian 3.14.15-2 (2014-08-09) i686 GNU/Linux ... gcc (Debian 4.9.1-12) 4.9.1 Copyright (C) 2014 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR PARTICULAR PURPOSE. ... ldd linux-gate.so.1 (0xb7733000) libm.so.6 => (0xb75da000) libc.so.6 => (0xb742f000) (0xb7734000) libgcc_s.so.1 => (0xb7411000) */ #include using namespace std; using namespace __gnu_cxx; class public: (); (); "hello world!\n"; }; () cout all, unsigned int size, void* pt, t){ try all->allocate (size, pt); cout max_size () s) cout *all new __gnu_cxx ::new_allocator (); t; void* pt &t; /** What happens when new can find no store to allocate? By default, the allocator throws stan- dard-library bad_alloc exception (for an alternative, see §11.2.4.1) @C Bjarne Stroustrup The C++ Programming language */ unsigned int size 1073741824; alloc(all, size, &pt, &t); size 1; alloc(all, size, &pt, &t); return 0; ==তথ্যসূত্র== ==বহি:স্থ লিঙ্কসমূহ== CodeGuru: Allocators (STL). *An introductory article "C++ Standard Allocator, An Introduction and custom allocator implementation based on malloc বিষয়শ্রেণী:C++ Standard Library programming with example C++ code