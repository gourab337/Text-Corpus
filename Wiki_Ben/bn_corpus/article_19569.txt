অবজেক্ট ওরিয়েন্টেড প্রোগ্রামিং একটি '''মেথড''' হলো একটি ফাংশন বা সাবরুটিন যা একটি ক্লাসের সাথে সম্পর্কিত। মেথড একটি ক্লাসের এর গতিবিধি নির্ধারণ করে প্রোগ্রামের রানটাইমে। মেথডের একটি বৈশিষ্ট্য হলো এরা রানটাইমে একটি ক্লাসের ইন্সট্যান্স সংরক্ষিত তথ্য নিয়ে কাজ করতে পারে এবং ইন্সট্যান্স এর অবস্থা(state) নিয়ন্ত্রণ করতে পারে। ক্লাস এবং মেথডের সম্পর্ককে বলা হয় বাইন্ডিং। সম্পর্কটি কম্পাইল করার সময় তৈরি হলে সেটাকে বলা হয় স্ট্যাটিক বাইন্ডিং, রানটাইমে তৈরি হলে বলা হয় ডাইনামিক বাইন্ডিং। == উদাহরণ == === জাভা === নিচের কোডে জাভাতে "মেইন" নামক ক্লাসে একটি মেথড তৈরি করা হয়েছে যা একটি আয়তক্ষেত্রের ক্ষেত্রফল নির্ণয় করতে পারে। public class Main int rectangle(int h,int w) return h*w; === সি++ === class Main public: int rectangle(int h,int w) return h*w; }; === পাইথন === নিচের পাইথন কোডে একটি ক্যালকুলেটর ক্লাস তৈরি করা হয়েছে যা দুটি নম্বর যোগ করতে পারে। class Calculator: def set( self, first, second ): self.a first self.b second def add( self ): return self.a self.b == অ্যাবস্ট্রাক্ট মেথড == অ্যাবস্ট্রাক্ট মেথডে মেথডটি কিভাবে কাজ করবে বলা হয়না,শুধুমাত্র মেথডে সিগনেচার দেয়া থাকে। অন্য একটি সাবক্লাস মেথডটিকে কাজ বর্ণনা করে। জাভাসহ কিছু কিছু প্রোগ্রামিং ভাষায় ইন্টারফেস তৈরি করতে অ্যাবস্ট্রাক্ট মেথড ব্যবহার করা হয়। === উদাহরণ === প্রথম জাভা কোডটিতে একটি অ্যাবস্ট্রাক্ট ক্লাসে একটি অ্যাবস্ট্রাক্ট মেথডের সিগনেচার তৈরি করা হয়েছে। পরে Main2 সাবক্লাসটি মেথডটি বর্ণনা করেছে। abstract class Main{ abstract int rectangle(int h,int w); public class Main2 extends Main{ @Override int rectangle(int h,int w) return h*w; == ওভারলোডেড মেথড == একটি ক্লাসে একই নামে একাধিক মেথড তৈরি করা যায়। তবে একই নামের যেকোনো দুটি মেথডের সবগুলো প্যারামিটার রিটার্ণটাইপ একই হতে পারবেনা। মেথড কল করার সময় প্যারামিটার আর রিটার্ণ টাইপ দেখে বুঝে নেয়া হয় কোন মেথডটিকে কল করা হয়ছে। একে ওভারলোডেড মেথড বা মেথড ওভারলোডিং বা ফাংশন ওভারলোডিং বলা হয়। === উদাহরণ === নিচের সি++ কোডে জিওমেট্রি ক্লাসের মধ্যে দুটি এরিয়া মেথড তৈরি করা হয়েছে। দুটির প্যারামিটার ভিন্ন। #include using namespace std; class geometry{ public: static double area(double h,double w){ return h*w; static double area(double r){ return r*r*3.14; }; int main(){ double double cout == ওভাররিডেন মেথড == কোনো ক্লাসের মেথডকে সাবক্লাসে নতুন করে বর্ণনা করা হলে তাকে মেথড বলা হয়। এটা সুপারক্লাসের আসল মেথডকে লুকিয়ে সাবক্লাসে নতুন করে বর্ণনা করে। ওভারলোডেড মেথডের সাথে এটার পার্থক্য হলো এক্ষেত্রে মেথড দুটি ভিন্ন ভিন্ন ক্লাসে থাকে। ওভাররিডেন মেথডের ক্ষেত্রে নতুন মেথডের প্যারামিটার রিটার্ণ টাইপ আসল মেথডের সমান হতে পারে। === উদাহরণ === নিচের জাভা কোডে ক্লাস১ এর মেথডকে ওভাররাইড করেছে ক্লাস২ এর মেথড। ক্লাস২ এর ২য় মেথডটি প্রথমটিকে ওভারলোড করেছে। public class class1 int f(int x) return x+3; public class class2 extends class1 @Override int f(int x) //overriding return x*x; int f(int x,int y) //overloading return x*y; == অপারেটর মেথড == অপারেটর মেথড ক্লাসে +,-, ইত্যাদি অপারেটরের কাজ নির্ধারণ করে। === উদাহরণ === class data public: string name; int roll; bool operator == কনস্ট্রাক্টর মেথড == একটি ক্লাসের ইনস্ট্যান্স তৈরি করার সময় কনস্ট্রাক্টর মেথড কল হয়। কনস্ট্রাক্টর মেথড মূলত ব্যবহার করা হয় ক্লাসের প্রাথমিক মান নির্ধারণ করা জন্য এবং ক্লাসটিকে কাজ করতে প্রস্তুত করার জন্য। কনস্ট্রাক্টর মেথডের নাম আর ক্লাসের নাম একই হতে হয় এবং মেথডটি প্যারামিটার গ্রহণ করলেও কোনো রিটার্ন টাইপ থাকেনা। কোনো কনস্ট্রাক্টর মেথড ডিক্লেয়ার করা না হলে ডিফল্ট কনস্ট্রাকটরকে কল করা হয়। ওভারলোডিং এর মাধ্যমে একটি ক্লাসে একাধিক কনস্ট্রাক্টর ডিক্লেয়ার করা যায়। === উদাহরণ === নিচের জাভা কোডে মেইন নামক ক্লাসে কনস্ট্রাক্টরের সাহায্যে প্রাথমিক মান নির্ধারণ করা হয়েছে। public class Main String name; int roll; Main(String _name,int _roll){ //constructor method == ডিস্ট্রাক্টর মেথড == যখন একটা অবজেক্টের জীবনকাল শেষ হয়ে যায় তখন স্বয়ংক্রিয় ভাবে ডিস্ট্রাক্টর মেথড কল করা হয় মেমরি থেকে অবজেক্টটি সরিয়ে নেবার জন্য। === উদাহরণ === #include #include class foo public: foo( void print( "foo()" ); ~foo( void print( "~foo()" ); void print( std::string const& text std::cout this == আরো দেখুন == সাবরুটিন == তথ্যসূত্র == ওরিয়েন্টেড প্রোগ্রামিং প্রোগ্রামিং